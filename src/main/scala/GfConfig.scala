package Rs

import chisel3._
import scala.collection.mutable.ArrayBuffer
import chisel3.util.{log2Ceil}
import scala.math.floor
import play.api.libs.json._
import scala.io.Source

case class JsonConfig(SYMB_WIDTH: Int, BUS_WIDTH: Int, POLY: Int, FCR: Int, N_LEN: Int, K_LEN: Int)

case class Config(SYMB_WIDTH: Int, BUS_WIDTH: Int, POLY: Int, FCR: Int, N_LEN: Int, K_LEN: Int, REDUNDANCY: Int, T_LEN: Int) {

  val SYMB_NUM = 1 << SYMB_WIDTH
  val FIELD_CHAR = SYMB_NUM-1
  val FIRST_ROOT_POWER = 1
  val MSG_DURATION = N_LEN/BUS_WIDTH

  //////////////////////////////
  // Berlekamp Massey Parameters
  //////////////////////////////

  // bmTermsPerCycle - defines the number of syndrome terms BM can process in a cycle(calculated sequentially)
  val bmTermsPerCycle = 1
  val bmLatency = math.ceil(REDUNDANCY/bmTermsPerCycle.toDouble).toInt
  val bmLatencyFull = bmLatency + 2 // shiftBundle capture + shiftBundle shift + output reg

  //////////////////////////////
  // Chien search parameters:
  //////////////////////////////

  // chienRootsPerCycle - defines number of roots generated by RsChienErrBitPos block
  val chienRootsPerCycle = 16
  // chienPosToNumComboLen - this parameter is used for pipelining the block. This parameter determines after how many stages a register is inserted.  
  val chienHorner = false // TODO: add substitution for Horner PolyEval

  val chienErrBitPosLatency = math.ceil((SYMB_NUM-1)/chienRootsPerCycle.toDouble).toInt-1 // -1 since it's started same cycle when errLocIf_valid = 1
  val chienErrBitPosLatencyFull = chienErrBitPosLatency + 1

  val chienPosToNumComboLen = 1
  require(chienPosToNumComboLen <= T_LEN-1, "chienPosToNumComboLen more than (T_LEN-1)")
  val chienBitPosLatency = if(chienPosToNumComboLen == T_LEN-1) 0 else (T_LEN-1)/chienPosToNumComboLen
  val chienBitPosLatencyFull = chienBitPosLatency + 2 // +1 captFfsQ +1 errPosIf.valid

  val chienLatencyFull = chienBitPosLatencyFull + chienErrBitPosLatencyFull

  //////////////////////////////
  // Forney algorithm parameters
  //////////////////////////////

  // ErrataLoc - defines number of error position coefficients ErrataLoc block can process in a cycle(recursive function/feedback accumulator)
  val forneyErrataLocTermsPerCycle = 2
  val forneyErrataLocShiftLatency = math.ceil((T_LEN)/forneyErrataLocTermsPerCycle.toDouble).toInt
  val forneyErrataLocLatencyFull = forneyErrataLocShiftLatency + 1 // +1 output reg

  // ErrEval
  // forneyErrEvalTermsPerCycle - defines number of errata locator terms ErrEval block can process in a cycle(calculated in parallel)
  val forneyErrEvalTermsPerCycle = 3
  val forneyErrEvalShiftLatency = math.ceil((T_LEN+1)/forneyErrEvalTermsPerCycle.toDouble).toInt
  val forneyErrEvalLatencyFull = forneyErrEvalShiftLatency + 3 // +1 accumVld +1 syndXErrataLocVld +1 errEvalIf.valid

  // ErrEvalXlInv
  // forneyEEXlInvTermsPerCycles - defines number of XlInv terms ErrEvalXlInv block can process in a cycle(calculated in parallel)
  val forneyEEXlInvTermsPerCycles = 3
  val forneyEEXlInvShiftLatency = math.ceil(T_LEN/forneyEEXlInvTermsPerCycles.toDouble).toInt

  // forneyEEXlInvComboLen - this parameter is used for pipelining the stage of ErrEvalXlInv block. This parameter determines after how many stages a register is inserted.
  val forneyEEXlInvComboLen = 3
  require(forneyEEXlInvComboLen <= T_LEN-1, "ErrEvalXlInvStage combo length more than (T_LEN-1)")
  val forneyEEXlInvQStages = if(forneyEEXlInvComboLen == T_LEN-1) 1 else (T_LEN-1)/forneyEEXlInvComboLen+1
  val forneyEEXlInvShiftLatencyFull = forneyEEXlInvQStages + forneyEEXlInvShiftLatency + 2 // +1 accumVld +1 output reg

  // FD - formal derivative params
  // forneyFdTermsPerCycle - defines number of XlInv terms FormalDerivative block can process in a cycle(calculated in parallel)
  val forneyFdTermsPerCycle = 3
  val forneyFdShiftLatency = math.ceil(T_LEN/forneyFdTermsPerCycle.toDouble).toInt
  val forneyFdStopLimit = forneyFdTermsPerCycle * forneyFdShiftLatency // 8
  val forneyFdEop  = forneyFdTermsPerCycle * (forneyFdShiftLatency-1)
  val forneyFdComboLen = 2
  val forneyFdQStages = (T_LEN-1)/forneyFdComboLen

  val forneyFdFullLatency = forneyFdShiftLatency + forneyFdQStages + 2 // +1 accumVld +1 output reg

  // ErrVal
  val forneyEvTermsPerCycle = 3
  val forneyEvShiftLatency = math.ceil(T_LEN/forneyEvTermsPerCycle.toDouble).toInt
  val forneyEvFullLatency = forneyEvShiftLatency + 1 // +1 accum

  val decoderLatencyFull = bmLatencyFull + chienErrBitPosLatencyFull + chienBitPosLatencyFull + forneyErrataLocLatencyFull + forneyErrEvalLatencyFull + forneyEEXlInvShiftLatencyFull + forneyFdFullLatency + forneyEvFullLatency

  val msgNum = math.ceil((MSG_DURATION + decoderLatencyFull)/MSG_DURATION.toDouble).toInt + 1 // +1 to make sure it's enough

  // If the latency in between RsSyndrome output and ErrEval block > MSG_DURATION,
  // then syndrome value will be updated before it's used in ErrEval block.
  // In this case syndrome FIFO inserted in the Forney block.
  val syndErrEvalLatency = bmLatencyFull + chienLatencyFull + forneyErrataLocLatencyFull + forneyErrEvalLatencyFull
  val forneySyndFifoEn = if(syndErrEvalLatency > MSG_DURATION) true else false
  val forneySyndFifoDepth = math.ceil(syndErrEvalLatency/MSG_DURATION.toDouble).toInt

  println(s"Message duration = $MSG_DURATION")
  println(s"BM latency       = $bmLatencyFull")
  println(s"Chien latency    = $chienLatencyFull")
  println(s"Decoder latency  = $decoderLatencyFull")
  println(s"syndErrEvalLatency = $syndErrEvalLatency")
  if(forneySyndFifoEn)
    println(s"Syndrome FIFO enabled in forney block")
  println(s"FIFO should store $msgNum messages.")


  //////////////////////////////
  // GF arithmetic
  //////////////////////////////

  def genAlphaToSymb() : Seq[Int] = {
    val alpha_to_symb = new ArrayBuffer[Int](1 << SYMB_WIDTH)
    alpha_to_symb += 1
    for(i <- 1 until (1 << SYMB_WIDTH)) {
      if((alpha_to_symb(i-1) & (1 << (SYMB_WIDTH-1))) != 0)
        alpha_to_symb += (alpha_to_symb(i-1) << 1) ^ POLY
      else
        alpha_to_symb += (alpha_to_symb(i-1) << 1)
      //println(alpha_to_symb(i))
    }
    alpha_to_symb.toSeq
  }

  def genSymbToAlpha (alphaToSymbTbl: Seq[Int]) : Seq[Int] = {
    val symbToAlphaTbl = ArrayBuffer.fill(1 << SYMB_WIDTH)(0)
    for(i <- 0 until (1 << SYMB_WIDTH)-1) {
      symbToAlphaTbl(alphaToSymbTbl(i)) = i
    }
    symbToAlphaTbl.toSeq
  }

  def alphaToSymb(alpha: UInt): UInt = {
    val alphaToSymbTbl = VecInit(genAlphaToSymb().map(_.U))
    val symb = Wire(UInt(SYMB_WIDTH.W))
    symb := alphaToSymbTbl(alpha)
    symb
  }

  def symbToAlpha(symb: UInt): UInt = {
    val symbToAlphaTbl = VecInit(genSymbToAlpha(genAlphaToSymb()).map(_.U))
    val alpha = Wire(UInt(SYMB_WIDTH.W))
    alpha := symbToAlphaTbl(symb)
    alpha
  }

  def gfMult (symbA: UInt, symbB: UInt) : UInt = {
    val mult = Wire(UInt(SYMB_WIDTH.W))
    val alphaSum = Wire(UInt(SYMB_WIDTH.W))
    val alphaA = Wire(UInt(SYMB_WIDTH.W))
    val alphaB = Wire(UInt(SYMB_WIDTH.W))
    alphaA := symbToAlpha(symbA)
    alphaB := symbToAlpha(symbB)
    alphaSum := (alphaA + alphaB) % FIELD_CHAR.U
    when((symbA === 0.U) | (symbB === 0.U)){
      mult := 0.U
    }.otherwise{
      mult := alphaToSymb(alphaSum)
    }
    mult
  }

  def gfDiv (dividend: UInt, divider: UInt) : UInt = {
    val alphaDivd = symbToAlpha(dividend)
    val alphaDvdr = symbToAlpha(divider)
    // TODO: use +& instead of implicit cast.
    val alphaDiff = (FIELD_CHAR.U.asTypeOf(UInt((SYMB_WIDTH+1).W))+alphaDivd-alphaDvdr)%FIELD_CHAR.U
    val gfDivVal = Wire(UInt(SYMB_WIDTH.W))
    when(dividend === 0.U) {
      gfDivVal := 0.U
    }.otherwise {
      gfDivVal := alphaToSymb(alphaDiff)
    }
    gfDivVal
  }
  
  def gfInv(symb : UInt) : UInt = {
    val alphaInv = Wire(UInt(SYMB_WIDTH.W))
    alphaInv := (SYMB_NUM - 1).U - symbToAlpha(symb)
    val gfInverse =alphaToSymb(alphaInv)
    gfInverse
  }

  def gfPow(x : UInt, degree : UInt) : UInt = {
    val alpha = symbToAlpha(x)
    val alphaPow = (alpha * degree) % FIELD_CHAR.U
    val xDegree = alphaToSymb(alphaPow)
    xDegree
  }

  def gfPolyMultX(poly: Vec[UInt]) : Vec[UInt] = {
    val outVec = Wire(poly.cloneType)
    outVec(0) := 0.U
    for(i <- 0 until poly.size-1) {
      outVec(i+1) := poly(i)
    }
    outVec
  }

  ////////////////////////////////////////////
  // GF poly operations 
  ////////////////////////////////////////////

  // TODO: simplify if firstRoot == 2(firstRootPower = 1)
  // then:
  // genPowerFirstRootTbl += i % fieldChar
  def genPowerFirstRoot() : Seq[Int] = {
    val genPowerFirstRootTbl = new ArrayBuffer[Int](N_LEN)
    for(i <- 0 until N_LEN) {
      genPowerFirstRootTbl += (FIRST_ROOT_POWER * i) % FIELD_CHAR
    }
    genPowerFirstRootTbl.toSeq
  }

  def genPowerFirstRootNeg() : Seq[Int] = {
    val genPowerFirstRootNegTbl = new ArrayBuffer[Int](N_LEN)
    for(i <- 0 until N_LEN) {
      genPowerFirstRootNegTbl += (FIRST_ROOT_POWER*(FIELD_CHAR-i)) % FIELD_CHAR
    }
    genPowerFirstRootNegTbl.toSeq
  }

  def powerFirstRootNeg(powOfSymb: UInt) : UInt = {
    val powerFirstRootNegTbl = VecInit(genPowerFirstRootNeg().map(_.U))
    val powFirstRootNeg = alphaToSymb(powerFirstRootNegTbl(powOfSymb))
    powFirstRootNeg
  }

  def genPowerFirstRootMin1() : Seq[Int] = {
    val genPowerFirstRootTbl = new ArrayBuffer[Int](N_LEN)
    for(i <- 0 until N_LEN) {
      genPowerFirstRootTbl += ((FIRST_ROOT_POWER-1) * i) % FIELD_CHAR
    }
    genPowerFirstRootTbl.toSeq
  }

  def powerFirstRootMin1(powOfSymb: UInt) : UInt = {
    val powerFirstRootMin1Tbl = VecInit(genPowerFirstRootMin1().map(_.U))
    val powFirstRootMin1 = alphaToSymb(powerFirstRootMin1Tbl(powOfSymb))
    powFirstRootMin1
  }

  def powerFirstRoot(powOfSymb: UInt) : UInt = {
    val powerFirstRootTbl = VecInit(genPowerFirstRoot().map(_.U))
    val powFirstRoot = alphaToSymb(powerFirstRootTbl(powOfSymb))
    powFirstRoot
  }


}

// Full config objects
object Config {
  def apply(jsonConfig: JsonConfig): Config = {
    val REDUNDANCY = jsonConfig.N_LEN - jsonConfig.K_LEN
    val T_LEN = REDUNDANCY/2
    Config(jsonConfig.SYMB_WIDTH, jsonConfig.BUS_WIDTH, jsonConfig.POLY, jsonConfig.FCR, jsonConfig.N_LEN, jsonConfig.K_LEN, REDUNDANCY, T_LEN)
  }
}

object JsonReader {
  implicit val configReads: Reads[JsonConfig] = Json.reads[JsonConfig]

  def readConfig(filePath: String): Config = {
    val source = Source.fromFile(filePath)
    val jsonString = try source.mkString finally source.close()
    val jsonConfig = Json.parse(jsonString).as[JsonConfig]
    Config(jsonConfig)
  }
}

// Bundles
class axisIf(width: Int, symbWidth: Int) extends Bundle {
  val tdata = Vec(width, UInt(symbWidth.W))
  val tkeep = UInt(width.W)
  val tlast = Bool()
}

class vecFfsIf(width: Int, symbWidth: Int) extends Bundle {
  val vec = Vec(width, UInt(symbWidth.W))
  val ffs = UInt(width.W)
}

class BitPosIf(width: Int) extends Bundle {
  val valid = Bool()
  val last  = Bool()
  val pos   = UInt(width.W)
}



