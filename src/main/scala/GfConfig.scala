package Rs

import chisel3._
import scala.collection.mutable.ArrayBuffer
import chisel3.util.{log2Ceil}
import scala.math.floor
import play.api.libs.json._
import scala.io.Source

case class JsonConfig(SYMB_WIDTH: Int, BUS_WIDTH: Int, POLY: Int, FCR: Int, N_LEN: Int, K_LEN: Int)

case class Config(SYMB_WIDTH: Int, BUS_WIDTH: Int, POLY: Int, FCR: Int, N_LEN: Int, K_LEN: Int, REDUNDANCY: Int, T_LEN: Int) {

  val SYMB_NUM = 1 << SYMB_WIDTH
  val FIELD_CHAR = SYMB_NUM-1
  val FIRST_ROOT_POWER = 1

  //////////////////////////////
  // Block Parameters
  //////////////////////////////

  // Berlekamp Massey : 
  // numOfSymbBm - defines the number of syndrome terms BM can process in a cycle(calculated sequentially)
  val numOfSymbBm = 1

  // Chisen search : 
  // chienRootsPerCycle - defines number of roots generated by RsChienErrBitPos block
  // chienPosToNumComboLen - The parameter is used for pipelining the block. This parameter determines after how many stages a register is inserted.
  val chienRootsPerCycle = 16
  val chienPosToNumComboLen = 1
  val chienHorner = false // TODO: add substitution for Horner PolyEval

  // Forney algorithm

  // ErrEval
  // numOfSymbEe - defines number of errata locator terms ErrEval block can process in a cycle(calculated in parallel)
  val numOfSymbEe = 3

  // ErrEvalXlInv
  // numOfQStagesEeXl - defines number of XlInv terms ErrEvalXlInv block can process in a cycle(calculated in parallel)
  val numOfStagesEeXl = 3
  val numOfComboLenEeXl = 3

  require(numOfComboLenEeXl <= T_LEN-1, "Ee0 Combo length more than (T_LEN-1)")
  val numOfQStagesEeXl = if(numOfComboLenEeXl == T_LEN-1) 1 else (T_LEN-1)/numOfComboLenEeXl+1

  // ErrVal
  val numOfSymbEv = 3

  // ErrataLoc
  val numOfErrataLocStages = 2

  // FD - formal derivative params
  val numOfStagesFd0 = 3
  val numOfCyclesFd0 = math.ceil(T_LEN/numOfStagesFd0.toDouble).toInt
  val cntrStopLimitFd0 = numOfStagesFd0 * numOfCyclesFd0 // 8
  val cntrEopFd0  = numOfStagesFd0 * (numOfCyclesFd0-1)
  val numOfComboLenFd1 = 3
  val numOfQStagesFd1 = (T_LEN-1)/numOfComboLenFd1

  //////////////////////////////
  // GF arithmetic
  //////////////////////////////

  def genAlphaToSymb() : Seq[Int] = {
    val alpha_to_symb = new ArrayBuffer[Int](1 << SYMB_WIDTH)
    alpha_to_symb += 1
    for(i <- 1 until (1 << SYMB_WIDTH)) {
      if((alpha_to_symb(i-1) & (1 << (SYMB_WIDTH-1))) != 0)
        alpha_to_symb += (alpha_to_symb(i-1) << 1) ^ POLY
      else
        alpha_to_symb += (alpha_to_symb(i-1) << 1)
      //println(alpha_to_symb(i))
    }
    alpha_to_symb.toSeq
  }

  def genSymbToAlpha (alphaToSymbTbl: Seq[Int]) : Seq[Int] = {
    val symbToAlphaTbl = ArrayBuffer.fill(1 << SYMB_WIDTH)(0)
    for(i <- 0 until (1 << SYMB_WIDTH)-1) {
      symbToAlphaTbl(alphaToSymbTbl(i)) = i
    }
    symbToAlphaTbl.toSeq
  }

  def alphaToSymb(alpha: UInt): UInt = {
    val alphaToSymbTbl = VecInit(genAlphaToSymb().map(_.U))
    val symb = Wire(UInt(SYMB_WIDTH.W))
    symb := alphaToSymbTbl(alpha)
    symb
  }

  def symbToAlpha(symb: UInt): UInt = {
    val symbToAlphaTbl = VecInit(genSymbToAlpha(genAlphaToSymb()).map(_.U))
    val alpha = Wire(UInt(SYMB_WIDTH.W))
    alpha := symbToAlphaTbl(symb)
    alpha
  }

  def gfMult (symbA: UInt, symbB: UInt) : UInt = {
    val mult = Wire(UInt(SYMB_WIDTH.W))
    val alphaSum = Wire(UInt(SYMB_WIDTH.W))
    val alphaA = Wire(UInt(SYMB_WIDTH.W))
    val alphaB = Wire(UInt(SYMB_WIDTH.W))
    alphaA := symbToAlpha(symbA)
    alphaB := symbToAlpha(symbB)
    alphaSum := (alphaA + alphaB) % FIELD_CHAR.U
    when((symbA === 0.U) | (symbB === 0.U)){
      mult := 0.U
    }.otherwise{
      mult := alphaToSymb(alphaSum)
    }
    mult
  }

  def gfDiv (dividend: UInt, divider: UInt) : UInt = {
    val alphaDivd = symbToAlpha(dividend)
    val alphaDvdr = symbToAlpha(divider)
    // TODO: use +& instead of implicit cast.
    val alphaDiff = (FIELD_CHAR.U.asTypeOf(UInt((SYMB_WIDTH+1).W))+alphaDivd-alphaDvdr)%FIELD_CHAR.U
    val gfDivVal = Wire(UInt(SYMB_WIDTH.W))
    when(dividend === 0.U) {
      gfDivVal := 0.U
    }.otherwise {
      gfDivVal := alphaToSymb(alphaDiff)
    }
    gfDivVal
  }
  
  def gfInv(symb : UInt) : UInt = {
    val alphaInv = Wire(UInt(SYMB_WIDTH.W))
    alphaInv := (SYMB_NUM - 1).U - symbToAlpha(symb)
    val gfInverse =alphaToSymb(alphaInv)
    gfInverse
  }

  def gfPow(x : UInt, degree : UInt) : UInt = {
    val alpha = symbToAlpha(x)
    val alphaPow = (alpha * degree) % FIELD_CHAR.U
    val xDegree = alphaToSymb(alphaPow)
    xDegree
  }

  def gfPolyMultX(poly: Vec[UInt]) : Vec[UInt] = {
    val outVec = Wire(poly.cloneType)
    outVec(0) := 0.U
    for(i <- 0 until poly.size-1) {
      outVec(i+1) := poly(i)
    }
    outVec
  }

  ////////////////////////////////////////////
  // GF poly operations 
  ////////////////////////////////////////////

  // TODO: simplify if firstRoot == 2(firstRootPower = 1)
  // then:
  // genPowerFirstRootTbl += i % fieldChar
  def genPowerFirstRoot() : Seq[Int] = {
    val genPowerFirstRootTbl = new ArrayBuffer[Int](N_LEN)
    for(i <- 0 until N_LEN) {
      genPowerFirstRootTbl += (FIRST_ROOT_POWER * i) % FIELD_CHAR
    }
    genPowerFirstRootTbl.toSeq
  }

  def genPowerFirstRootNeg() : Seq[Int] = {
    val genPowerFirstRootNegTbl = new ArrayBuffer[Int](N_LEN)
    for(i <- 0 until N_LEN) {
      genPowerFirstRootNegTbl += (FIRST_ROOT_POWER*(FIELD_CHAR-i)) % FIELD_CHAR
    }
    genPowerFirstRootNegTbl.toSeq
  }

  def powerFirstRootNeg(powOfSymb: UInt) : UInt = {
    val powerFirstRootNegTbl = VecInit(genPowerFirstRootNeg().map(_.U))
    val powFirstRootNeg = alphaToSymb(powerFirstRootNegTbl(powOfSymb))
    powFirstRootNeg
  }

  def genPowerFirstRootMin1() : Seq[Int] = {
    val genPowerFirstRootTbl = new ArrayBuffer[Int](N_LEN)
    for(i <- 0 until N_LEN) {
      genPowerFirstRootTbl += ((FIRST_ROOT_POWER-1) * i) % FIELD_CHAR
    }
    genPowerFirstRootTbl.toSeq
  }

  def powerFirstRootMin1(powOfSymb: UInt) : UInt = {
    val powerFirstRootMin1Tbl = VecInit(genPowerFirstRootMin1().map(_.U))
    val powFirstRootMin1 = alphaToSymb(powerFirstRootMin1Tbl(powOfSymb))
    powFirstRootMin1
  }

  def powerFirstRoot(powOfSymb: UInt) : UInt = {
    val powerFirstRootTbl = VecInit(genPowerFirstRoot().map(_.U))
    val powFirstRoot = alphaToSymb(powerFirstRootTbl(powOfSymb))
    powFirstRoot
  }


}

// Full config objects
object Config {
  def apply(jsonConfig: JsonConfig): Config = {
    val REDUNDANCY = jsonConfig.N_LEN - jsonConfig.K_LEN
    val T_LEN = REDUNDANCY/2
    Config(jsonConfig.SYMB_WIDTH, jsonConfig.BUS_WIDTH, jsonConfig.POLY, jsonConfig.FCR, jsonConfig.N_LEN, jsonConfig.K_LEN, REDUNDANCY, T_LEN)
  }
}

object JsonReader {
  implicit val configReads: Reads[JsonConfig] = Json.reads[JsonConfig]

  def readConfig(filePath: String): Config = {
    val source = Source.fromFile(filePath)
    val jsonString = try source.mkString finally source.close()
    val jsonConfig = Json.parse(jsonString).as[JsonConfig]
    Config(jsonConfig)
  }
}

// Bundles
class axisIfNew(width: Int, symbWidth: Int) extends Bundle {
  val tdata = Vec(width, UInt(symbWidth.W))
  val tkeep = UInt(width.W)
  val tlast = Bool()
}

class vecFfsIf(width: Int, symbWidth: Int) extends Bundle {
  val vec = Vec(width, UInt(symbWidth.W))
  val ffs = UInt(width.W)
}

class BitPosIf(width: Int) extends Bundle {
  val valid = Bool()
  val last  = Bool()
  val pos   = UInt(width.W)
}



